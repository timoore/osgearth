/* -*-c++-*- */
/* osgEarth - Geospatial SDK for OpenSceneGraph
* Copyright 2020 Pelican Mapping
* http://osgearth.org
*
* osgEarth is free software; you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>
*/

#ifndef OSGEARTHUTIL_WINGED_EDGE_MESH_H
#define OSGEARTHUTIL_WINGED_EDGE_MESH_H 1

#include <osgEarth/Common>
#include <osgEarth/Math>
#include <algorithm>
#include <vector>
#include <deque>
#include <set>
#include <osg/Vec3>
#include <osg/Geometry>

    //! The vertices are stored rotated into the XY plane so that we can properly find
    //! the "bottom-most" vert and walk the boundary.
namespace osgEarth { namespace Util
{
    struct Empty
    {
    };
    template<typename Coord, typename V = Empty, typename E = Empty, typename F = Empty>
    class OSGEARTH_EXPORT WingedEdgeMesh : public osg::Referenced
    {
    public:
        class Edge;
        class Face;

        //! Represents a single vertex in the topology graph
        class Vertex : public V
        {
            Vertex(const Coord& pos)
                : position(pos)
            {
            }
            Coord position;
            // All Edge objects that has this vertex as the starting vertex (origVert)
            mutable std::vector<Edge*> edges;
        };

        using VVec = std::vector<const Vertex*>;
        struct Face : public F
        {
            Face(Edge* e = nullptr)
                : edge(e)
            {
            }
            // An edge that is adjacent to this face
            Edge* edge;
        };

        struct VertexCmp
        {
            bool operator()(const Coord& lhs, const Coord& rhs) const
            {
                if (lhs.x() < rhs.x())
                    return true;
                else if (lhs.x() > rhs.x())
                    return false;
                else
                    return lhs.y() < rhs.y();
            }

            bool operator()(const Vertex& lhs, const Vertex& rhs) const
            {
                return (*this)(lhs.position, rhs.position);
            }

            bool operator()(const Vertex& lhs, const Coord& rhs) const
            {
                return (*this)(lhs.position, rhs);
            }

            bool operator()(const Coord& lhs, const Vertex& rhs) const
            {
                return (*this)(lhs, rhs.position);
            }
        };
        
        //! One or more Vertex objects
        typedef std::set<Vertex, VertexCmp> VertexSet;

        const Vertex* getVertex(const Coord& position)
        {
            return &*vertices.emplace(position).first;
        }
        
        // Half Edges surround faces in counter-clockwise order
        // The vertices are in order for the left face
        struct Edge : public E
        {
            Edge(const Vertex* vOrig, const Vertex* vDest)
                : mate(nullptr), f(nullptr)
            {
                v[0] = vOrig;
                v[1] = vDest;
                e[0] = nullptr;
                e[1] = nullptr;
            }
            const Vertex* v[2];
            // left face
            Face* f;
            // edges - prev, next edge on left face
            Edge* e[2];
            const Vertex*& origVert()
            {
                return v[0];
            }
            const Vertex* origVert() const
            {
                return v[0];
            }
            const Vertex*& destVert()
            {
                return v[1];
            }
            const Vertex* destVert() const
            {
                return v[1];
            }
            Edge*& prevEdge()
            {
                return e[0];
            }
            Edge* prevEdge() const
            {
                return e[0];
            }
            Edge*& nextEdge()
            {
                return e[1];
            }
            Edge* nextEdge() const
            {
                return e[1];
            }
            // The half edge running in the other direction
            Edge* mate;
        };

        Edge* newEdge(const Vertex* vOrig, const Vertex* vDest)
        {
            edges.emplace_back(vOrig, vDest);
            return &edges.back();
        }

        Face* newFace(Edge* edge = nullptr)
        {
            faces.emplace_back(edge);
            return &faces.back();
        }

        ~WingedEdgeMesh()
        {
        }
        VertexSet vertices;
        std::deque<Edge> edges;
        std::deque<Face> faces;

        // Create a Face from a list of Vertex*
        template<typename VItr>
        Face* addFace(VItr begin, VItr end)
        {
            Face* f = newFace();
            Edge* firstEdge = nullptr, prevEdge = nullptr;
            VItr first = begin;
            // Set v0Itr to last vertex in new face
            VItr v0Itr = end - 1, v1Itr = first;
            for (; v1Itr != end; v0Itr = v1Itr++)
            {
                Edge* e = newEdge(*v0Itr, *v1Itr);
                if (!f->edge)
                {
                    f->edge = e;
                }
                e->face = f;
                // Search for the matching half-edge. It's origin will be
                // this edge's destination.
                auto mateEdgeItr = std::find_if((*v1Itr)->edges.begin(), (*v1Itr)->edges.end(),
                                                [v0Itr](const Edge* vertEdge)
                                                {
                                                    return *v0Itr == vertEdge->destVert();
                                                });
                if (mateEdgeItr != (*v1Itr)->edges.end())
                {
                    e->mate = *mateEdgeItr;
                    (*mateEdgeItr)->mate = e;
                }
                if (!firstEdge)
                {
                    firstEdge = e;
                }
                if (prevEdge)
                {
                    e->prevEdge() = prevEdge;
                    prevEdge->nextEdge() = e;
                }
                if (v1Itr + 1 = end)
                {
                    e->nextEdge() = firstEdge;
                    firstEdge->prevEdge() = e;
                }
                prevEdge = e;
                (*v0Itr)->vertex().edges.push_back(e);
            }
            return f;
        }

        bool removeEdge(Edge* e)
        {
            auto origVert = e->origVert();
            auto edgeInVerts = origVert->edges.find(e);
            if (edges != origVert->edges.end())
            {
                origVert->edges.erase(edgeInVerts);
            }
            if (e->mate)
            {
                e->mate->mate = nullptr;
            }
            if (auto prev = e->prevEdge())
            {
                prev->nextEdge() = nullptr;
            }
            if (auto next = e->nextEdge())
            {
                next->prevEdge() = nullptr;
            }
            return true;
        }

        bool removeFace(Face* f)
        {
            Edge* firstEdge = f->edge;
            for (Edge* edge = firstEdge->nextEdge(); edge != firstEdge; edge = edge->nextEdge())
            {
                removeEdge(edge);
            }
            removeEdge(firstEdge);
            return true;
        }

        VVec getFaceVertices(Face* f)
        {
            VVec result;
            result.push_back(f->edge->origVert());
            for (Edge* faceEdge = f->edge->nextEdge();
                 faceEdge != f->edge;
                 faceEdge = faceEdge->nextEdge())
            {
                result.push_back(faceEdge->origVert());
            }
            return result;
        }

        // Create new faces using a new vertex in the face
        void subdivideFace(Face* f, const Vertex* v)
        {
            auto faceVerts = getFaceVertices(f);
            removeFace(f);
            // Add back the triangles created by the subdivision.
            for (auto v0Itr = faceVerts.begin(); v0Itr != faceVerts.end(); ++v0Itr)
            {
                auto v1Itr = v0Itr + 1;
                if (v1Itr == faceVerts.end())
                {
                    v1Itr = faceVerts.begin();
                }
                const Vertex* varray[] = {v, *v0Itr, *v1Itr};
                addFace(&varray[0], &varray[3]);
            }
        }

        // Split an edge with a vertex connecting it to another vertex
        // on the same face as the edge. Then subdivide the face on the
        // other side of the edge.

        void splitOneFace(VVec& faceVerts, const Vertex* origVert, const Vertex* destVert, const Vertex* newVert,
                          VVec& out0, VVec& out1)
        {
            auto ovItr = std::find(faceVerts.begin(), faceVerts.end(), origVert);
            if (ovItr == faceVerts.begin())
            {
                out0.push_back(faceVerts.back());
            }
            else
            {
                out0.push_back(*(ovItr - 1));
            }
            out0.push_back(origVert);
            out0.push_back(newVert);
            out1.push_back(newVert);
            // Now all the way back to origVert, perhaps going around the
            // Horn
            auto out1VertItr = ovItr + 1; // points at destVert or faceVerts.end()
            if (out1VertItr != faceVerts.end())
            {
                out1.push_back(*out1VertItr);
            }
            for (++out1VertItr; out1VertItr != faceVerts.end() && out1VertItr != ovItr; ++out1VertItr)
            {
                out1.push_back(*out1VertItr);
            }
            if (out1VertItr == faceVerts.end())
            {
                for (out1VertItr = faceVerts.begin(); out1VertItr != ovItr; ++ out1VertItr)
                {
                    out1.push_back(*out1VertItr);
                }
            }
            // Now out1VertItr should point at origVert
            out1.push_back(origVert);
        }
    
        void splitEdge(Edge* e, const Vertex* v)
        {
            const Vertex* origVert = e->origVert();
            const Vertex* destVert = e->destVert();
            VVec faceVerts;
            VVec otherFaceVerts; // The face across the edge
            // Vertices for new faces
            VVec newFaces[4];
            Face* oldFace = e->face, oldOtherFace = nullptr;
            faceVerts = getFaceVertices(e->face);
            splitOneFace(faceVerts, origVert, destVert, v, newFaces[0], newFaces[1]);
            if (e->mate)
            {
                oldOtherFace = e->mate->face;
                otherFaceVerts = getFaceVertices(oldOtherFace);
                splitOneFace(otherFaceVerts, destVert, origVert, v, newFaces[2], newFaces[3]);
            }
            removeFace(oldFace);
            if (oldOtherFace)
            {
                removeFace(oldOtherFace);
            }
            for (int i = 0; i < 4; ++i)
            {
                if (!newFaces[i].empty())
                {
                    addFace(newFaces[i].begin(), newFaces[i].end());
                }
            }
        }

        void addGeometry(const osg::Geometry* geom)
        {
            const osg::Geometry::PrimitiveSetList& primSets = geom->getPrimitiveSetList();
            osg::Vec3Array* verts = dynamic_cast<osg::Vec3Array*>(geom->getVertexArray());
            for (auto primSet : primSets)
            {
                osg::DrawElementsUShort* de = dynamic_cast<osg::DrawElementsUShort*>(primSet.get());
                if (de && de->getMode() == osg::PrimitiveSet::TRIANGLES)
                {
                    for (int i = 0; i < de->getNumIndices(); i += 3)
                    {
                        Coord coords[3];
                        const Vertex* vtx[3];
                        for (int j = 0; j <  3; ++j)
                        {
                            coords[j] = (*verts)[de->index(i + j)];
                            vtx[j] = getVertex(coords[j]);
                        }
                        addFace(&vtx[0], &vtx[3]);
                    }
                }
            }
        }
        
        bool isPointInFace(const Face* f, const Coord& pt)
        {
            VVec faceVerts = getFaceVertices(f);
            std::vector<osg::Vec3d> coordVec(faceVerts.size());
            std::transform(faceVerts.begin(), faceVerts.end(), coordVec.begin(),
                           [](const Vertex* v)
                           {
                               return v->position;
                           });
            return pointInPoly2d(pt, coordVec.begin(), coordVec.end());
        }
        
        // Find the face that contains the point
        Face* getFaceContainingPoint(const Coord& pt)
        {
            // XXX Slow version
            for (auto face : faces)
            {
                if (face && isPointInFace(face, pt))
                {
                    return face;
                }
            }
            return nullptr;
        }

        bool vertsShareEdge(const Vertex* v0, const Vertex* v1)
        {
            for (auto& edge : v0->edges)
            {
                if (edge.destVert() == v1)
                    return true;
            }
            for (auto& edge : v1->edges)
            {
                if (edge.destVert() == v0)
                    return true;
            }
            return false;
        }

        Edge* intersectFaceSegment(Face* face, Segment2d& seg, Coord& intersection)
        {
            Edge* edge = face->edge;
            do
            {
                Segment2d edgeSeg(edge->origVert()->position, edge->destVert()->position);
                if (seg.intersect(edgeSeg, intersection))
                {
                    return edge;
                }
                edge = edge->nextEdge();
            }
            while (edge != face->edge);
            return nullptr;
        }

        bool cutSegment(const Segment2d& segment)
        {
            // 1) End points must lie on mesh vertices. If they don't
            // add those vertices.
            const Vertex* a = getVertex(segment._a);
            const Vertex* b = getVertex(segment._b);
            if (a->edges.empty())
            {
                Face* aFace = getFaceContainingPoint(a->position);
                subdivideFace(aFace);
            }
            if (b->edges.empty())
            {
                Face bFace = getFaceContainingPoint(b->position);
                subdivideFace(bFace);
            }
            const Vertex* current = a;
            // Proceed through the mesh along the mesh, attempting to
            // create an edge from our current vertex to the segment
            // end point.
            while (!vertsShareEdge(current, b))
            {
                Segment2d currSeg(coordinate(current), coordinate(b));
                // Look in adjacent faces for an edge that intersects
                // the segment
                Coord intersectPt;
                Edge* intersectEdge = nullptr;
                for (auto edge : current->edges)
                {
                    Face* face = edge->f;
                    if ((intersectEdge = intersectFaceSegment(face, currSeg, intersectPt)))
                    {
                        break;
                    }
                }
                if (!intersectEdge)
                {
                    // Urk, couldn't find an edge
                    return false;
                }
                current = getVertex(intersectPt);
                splitEdge(intersectEdge, current);
            }
            return true;
        }
    };
    
    
    }}
#endif
